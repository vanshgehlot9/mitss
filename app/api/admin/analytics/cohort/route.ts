import { NextRequest, NextResponse } from 'next/server'
import { requireAdmin } from '@/lib/ensure-admin'

interface CohortData {
  cohort: string
  month1: number
  month2: number
  month3: number
  month4: number
  month5: number
  month6: number
  totalUsers: number
}

interface RevenueCohort {
  cohort: string
  m1Revenue: number
  m2Revenue: number
  m3Revenue: number
  m4Revenue: number
  m5Revenue: number
  m6Revenue: number
}

/**
 * GET /api/admin/analytics/cohort
 *
 * Cohort analysis endpoints:
 * ?action=retention - Retention cohort analysis
 * ?action=revenue - Revenue cohort analysis
 * ?action=churn - Churn rate by cohort
 */
export async function GET(request: NextRequest) {
  try {
    const adminError = await requireAdmin(request)
    if (adminError) return adminError

    const { searchParams } = new URL(request.url)
    const action = searchParams.get('action')

    if (action === 'retention') {
      return handleRetentionCohort()
    } else if (action === 'revenue') {
      return handleRevenueCohort()
    } else if (action === 'churn') {
      return handleChurnByCohort()
    }

    return NextResponse.json(
      { success: false, message: 'Invalid action' },
      { status: 400 }
    )
  } catch (error) {
    console.error('Cohort analysis error:', error)
    return NextResponse.json(
      { success: false, message: 'Failed to fetch cohort data' },
      { status: 500 }
    )
  }
}

/**
 * Retention cohort analysis
 * Shows how many customers from each acquisition cohort stayed active
 */
async function handleRetentionCohort() {
  try {
    // Mock data for retention cohort
    const retentionCohorts: CohortData[] = [
      {
        cohort: 'Jan 2024',
        month1: 100,
        month2: 82,
        month3: 71,
        month4: 58,
        month5: 47,
        month6: 38,
        totalUsers: 100,
      },
      {
        cohort: 'Feb 2024',
        month1: 120,
        month2: 98,
        month3: 84,
        month4: 71,
        month5: 61,
        month6: 0,
        totalUsers: 120,
      },
      {
        cohort: 'Mar 2024',
        month1: 95,
        month2: 78,
        month3: 64,
        month4: 53,
        month5: 0,
        month6: 0,
        totalUsers: 95,
      },
      {
        cohort: 'Apr 2024',
        month1: 110,
        month2: 89,
        month3: 72,
        month4: 0,
        month5: 0,
        month6: 0,
        totalUsers: 110,
      },
      {
        cohort: 'May 2024',
        month1: 105,
        month2: 86,
        month3: 0,
        month4: 0,
        month5: 0,
        month6: 0,
        totalUsers: 105,
      },
      {
        cohort: 'Jun 2024',
        month1: 130,
        month2: 0,
        month3: 0,
        month4: 0,
        month5: 0,
        month6: 0,
        totalUsers: 130,
      },
    ]

    // Calculate retention percentages
    const retentionRates = retentionCohorts.map((cohort) => {
      const rates = {
        cohort: cohort.cohort,
        m1: 100,
        m2: (cohort.month2 / cohort.totalUsers) * 100,
        m3: (cohort.month3 / cohort.totalUsers) * 100,
        m4: (cohort.month4 / cohort.totalUsers) * 100,
        m5: (cohort.month5 / cohort.totalUsers) * 100,
        m6: (cohort.month6 / cohort.totalUsers) * 100,
      }
      return rates
    })

    // Calculate average retention by month
    const avgRetention = {
      m1: 100,
      m2: retentionRates.filter((r) => r.m2 > 0).reduce((sum, r) => sum + r.m2, 0) / retentionRates.length,
      m3: retentionRates.filter((r) => r.m3 > 0).reduce((sum, r) => sum + r.m3, 0) / retentionRates.length,
      m4: retentionRates.filter((r) => r.m4 > 0).reduce((sum, r) => sum + r.m4, 0) / retentionRates.length,
      m5: retentionRates.filter((r) => r.m5 > 0).reduce((sum, r) => sum + r.m5, 0) / retentionRates.length,
      m6: retentionRates.filter((r) => r.m6 > 0).reduce((sum, r) => sum + r.m6, 0) / retentionRates.length,
    }

    return NextResponse.json({
      success: true,
      data: {
        cohorts: retentionRates,
        averageRetention: avgRetention,
        insight: `Average retention drops to ${avgRetention.m2.toFixed(1)}% after 1 month`,
        recommendation: 'Focus on first-month engagement to improve retention',
      },
    })
  } catch (error) {
    console.error('Retention cohort error:', error)
    throw error
  }
}

/**
 * Revenue cohort analysis
 * Shows revenue generated by customers from each acquisition cohort
 */
async function handleRevenueCohort() {
  try {
    // Mock data for revenue cohort
    const revenueCohorts: RevenueCohort[] = [
      {
        cohort: 'Jan 2024',
        m1Revenue: 45000,
        m2Revenue: 28000,
        m3Revenue: 18000,
        m4Revenue: 12000,
        m5Revenue: 8000,
        m6Revenue: 5000,
      },
      {
        cohort: 'Feb 2024',
        m1Revenue: 52000,
        m2Revenue: 35000,
        m3Revenue: 22000,
        m4Revenue: 15000,
        m5Revenue: 9000,
        m6Revenue: 0,
      },
      {
        cohort: 'Mar 2024',
        m1Revenue: 38000,
        m2Revenue: 25000,
        m3Revenue: 15000,
        m4Revenue: 10000,
        m5Revenue: 0,
        m6Revenue: 0,
      },
      {
        cohort: 'Apr 2024',
        m1Revenue: 48000,
        m2Revenue: 32000,
        m3Revenue: 20000,
        m4Revenue: 0,
        m5Revenue: 0,
        m6Revenue: 0,
      },
      {
        cohort: 'May 2024',
        m1Revenue: 42000,
        m2Revenue: 28000,
        m3Revenue: 0,
        m4Revenue: 0,
        m5Revenue: 0,
        m6Revenue: 0,
      },
      {
        cohort: 'Jun 2024',
        m1Revenue: 55000,
        m2Revenue: 0,
        m3Revenue: 0,
        m4Revenue: 0,
        m5Revenue: 0,
        m6Revenue: 0,
      },
    ]

    // Calculate average revenue per user by cohort
    const cohortSizes = [100, 120, 95, 110, 105, 130]

    const avgRevenuePerUser = revenueCohorts.map((cohort, idx) => ({
      cohort: cohort.cohort,
      m1Arpu: cohort.m1Revenue / cohortSizes[idx],
      m2Arpu: cohort.m2Revenue > 0 ? cohort.m2Revenue / cohortSizes[idx] : 0,
      m3Arpu: cohort.m3Revenue > 0 ? cohort.m3Revenue / cohortSizes[idx] : 0,
      m4Arpu: cohort.m4Revenue > 0 ? cohort.m4Revenue / cohortSizes[idx] : 0,
      m5Arpu: cohort.m5Revenue > 0 ? cohort.m5Revenue / cohortSizes[idx] : 0,
      m6Arpu: cohort.m6Revenue > 0 ? cohort.m6Revenue / cohortSizes[idx] : 0,
    }))

    // Calculate lifetime revenue by cohort
    const lifetimeRevenue = revenueCohorts.map((cohort) => ({
      cohort: cohort.cohort,
      ltv: cohort.m1Revenue + cohort.m2Revenue + cohort.m3Revenue + cohort.m4Revenue + cohort.m5Revenue + cohort.m6Revenue,
    }))

    return NextResponse.json({
      success: true,
      data: {
        revenueCohorts,
        avgRevenuePerUser,
        lifetimeRevenue,
        avgLtv: lifetimeRevenue.reduce((sum, c) => sum + c.ltv, 0) / lifetimeRevenue.length,
        insight: `Average customer LTV is â‚¹${(lifetimeRevenue.reduce((sum, c) => sum + c.ltv, 0) / lifetimeRevenue.length).toLocaleString()}`,
      },
    })
  } catch (error) {
    console.error('Revenue cohort error:', error)
    throw error
  }
}

/**
 * Churn rate analysis by cohort
 */
async function handleChurnByCohort() {
  try {
    // Calculate churn rates
    const churnByMonth = [
      { month: 'Month 1-2', churnRate: 18 },
      { month: 'Month 2-3', churnRate: 13 },
      { month: 'Month 3-4', churnRate: 17 },
      { month: 'Month 4-5', churnRate: 19 },
      { month: 'Month 5-6', churnRate: 21 },
    ]

    const cohortChurnRates = [
      { cohort: 'Jan 2024', churnRate: 22, trend: 'up' },
      { cohort: 'Feb 2024', churnRate: 18, trend: 'down' },
      { cohort: 'Mar 2024', churnRate: 16, trend: 'down' },
      { cohort: 'Apr 2024', churnRate: 19, trend: 'up' },
      { cohort: 'May 2024', churnRate: 18, trend: 'down' },
      { cohort: 'Jun 2024', churnRate: 15, trend: 'down' },
    ]

    return NextResponse.json({
      success: true,
      data: {
        churnByMonth,
        cohortChurnRates,
        avgChurnRate: 17.8,
        highestChurnCohort: 'May 2024',
        lowestChurnCohort: 'Jun 2024',
        insight: 'Churn is highest between months 4-5. Focus on engagement strategies.',
        recommendations: [
          'Implement loyalty program for 4+ month customers',
          'Increase engagement emails after 90 days',
          'Offer incentives to prevent month 5-6 churn',
        ],
      },
    })
  } catch (error) {
    console.error('Churn cohort error:', error)
    throw error
  }
}

/**
 * POST /api/admin/analytics/cohort
 *
 * Actions:
 * - store-cohort-data: Store cohort analysis data to database
 * - update-cohort: Update specific cohort metrics
 */
export async function POST(request: NextRequest) {
  try {
    const adminError = await requireAdmin(request)
    if (adminError) return adminError

    const body = await request.json()
    const { action } = body

    if (action === 'store-cohort-data') {
      return handleStoreCohortData(body)
    } else if (action === 'update-cohort') {
      return handleUpdateCohort(body)
    }

    return NextResponse.json(
      { success: false, message: 'Invalid action' },
      { status: 400 }
    )
  } catch (error) {
    console.error('Cohort POST error:', error)
    return NextResponse.json(
      { success: false, message: 'Failed to process cohort data' },
      { status: 500 }
    )
  }
}

async function handleStoreCohortData(body: any) {
  try {
    const { cohortData, month } = body

    // In production, this would store to Firebase/MongoDB
    // For now, return success
    return NextResponse.json({
      success: true,
      message: `Cohort data for ${month} stored successfully`,
      data: {
        storedAt: new Date().toISOString(),
        recordCount: cohortData.length,
      },
    })
  } catch (error) {
    throw error
  }
}

async function handleUpdateCohort(body: any) {
  try {
    const { cohortId, metrics } = body

    // In production, update the cohort in database
    return NextResponse.json({
      success: true,
      message: 'Cohort updated successfully',
      data: {
        cohortId,
        updatedMetrics: metrics,
        updatedAt: new Date().toISOString(),
      },
    })
  } catch (error) {
    throw error
  }
}
